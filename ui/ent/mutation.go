// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/grokify/omniproxy/ui/ent/org"
	"github.com/grokify/omniproxy/ui/ent/predicate"
	"github.com/grokify/omniproxy/ui/ent/proxy"
	"github.com/grokify/omniproxy/ui/ent/session"
	"github.com/grokify/omniproxy/ui/ent/traffic"
	"github.com/grokify/omniproxy/ui/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeOrg     = "Org"
	TypeProxy   = "Proxy"
	TypeSession = "Session"
	TypeTraffic = "Traffic"
	TypeUser    = "User"
)

// OrgMutation represents an operation that mutates the Org nodes in the graph.
type OrgMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	slug                      *string
	plan                      *org.Plan
	traffic_retention_days    *int
	addtraffic_retention_days *int
	max_proxies               *int
	addmax_proxies            *int
	active                    *bool
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	users                     map[int]struct{}
	removedusers              map[int]struct{}
	clearedusers              bool
	proxies                   map[int]struct{}
	removedproxies            map[int]struct{}
	clearedproxies            bool
	done                      bool
	oldValue                  func(context.Context) (*Org, error)
	predicates                []predicate.Org
}

var _ ent.Mutation = (*OrgMutation)(nil)

// orgOption allows management of the mutation configuration using functional options.
type orgOption func(*OrgMutation)

// newOrgMutation creates new mutation for the Org entity.
func newOrgMutation(c config, op Op, opts ...orgOption) *OrgMutation {
	m := &OrgMutation{
		config:        c,
		op:            op,
		typ:           TypeOrg,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgID sets the ID field of the mutation.
func withOrgID(id int) orgOption {
	return func(m *OrgMutation) {
		var (
			err   error
			once  sync.Once
			value *Org
		)
		m.oldValue = func(ctx context.Context) (*Org, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Org.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrg sets the old Org of the mutation.
func withOrg(node *Org) orgOption {
	return func(m *OrgMutation) {
		m.oldValue = func(context.Context) (*Org, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Org.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *OrgMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrgMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrgMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *OrgMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *OrgMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *OrgMutation) ResetSlug() {
	m.slug = nil
}

// SetPlan sets the "plan" field.
func (m *OrgMutation) SetPlan(o org.Plan) {
	m.plan = &o
}

// Plan returns the value of the "plan" field in the mutation.
func (m *OrgMutation) Plan() (r org.Plan, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlan returns the old "plan" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldPlan(ctx context.Context) (v org.Plan, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlan: %w", err)
	}
	return oldValue.Plan, nil
}

// ResetPlan resets all changes to the "plan" field.
func (m *OrgMutation) ResetPlan() {
	m.plan = nil
}

// SetTrafficRetentionDays sets the "traffic_retention_days" field.
func (m *OrgMutation) SetTrafficRetentionDays(i int) {
	m.traffic_retention_days = &i
	m.addtraffic_retention_days = nil
}

// TrafficRetentionDays returns the value of the "traffic_retention_days" field in the mutation.
func (m *OrgMutation) TrafficRetentionDays() (r int, exists bool) {
	v := m.traffic_retention_days
	if v == nil {
		return
	}
	return *v, true
}

// OldTrafficRetentionDays returns the old "traffic_retention_days" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldTrafficRetentionDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrafficRetentionDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrafficRetentionDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrafficRetentionDays: %w", err)
	}
	return oldValue.TrafficRetentionDays, nil
}

// AddTrafficRetentionDays adds i to the "traffic_retention_days" field.
func (m *OrgMutation) AddTrafficRetentionDays(i int) {
	if m.addtraffic_retention_days != nil {
		*m.addtraffic_retention_days += i
	} else {
		m.addtraffic_retention_days = &i
	}
}

// AddedTrafficRetentionDays returns the value that was added to the "traffic_retention_days" field in this mutation.
func (m *OrgMutation) AddedTrafficRetentionDays() (r int, exists bool) {
	v := m.addtraffic_retention_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetTrafficRetentionDays resets all changes to the "traffic_retention_days" field.
func (m *OrgMutation) ResetTrafficRetentionDays() {
	m.traffic_retention_days = nil
	m.addtraffic_retention_days = nil
}

// SetMaxProxies sets the "max_proxies" field.
func (m *OrgMutation) SetMaxProxies(i int) {
	m.max_proxies = &i
	m.addmax_proxies = nil
}

// MaxProxies returns the value of the "max_proxies" field in the mutation.
func (m *OrgMutation) MaxProxies() (r int, exists bool) {
	v := m.max_proxies
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxProxies returns the old "max_proxies" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldMaxProxies(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxProxies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxProxies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxProxies: %w", err)
	}
	return oldValue.MaxProxies, nil
}

// AddMaxProxies adds i to the "max_proxies" field.
func (m *OrgMutation) AddMaxProxies(i int) {
	if m.addmax_proxies != nil {
		*m.addmax_proxies += i
	} else {
		m.addmax_proxies = &i
	}
}

// AddedMaxProxies returns the value that was added to the "max_proxies" field in this mutation.
func (m *OrgMutation) AddedMaxProxies() (r int, exists bool) {
	v := m.addmax_proxies
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxProxies resets all changes to the "max_proxies" field.
func (m *OrgMutation) ResetMaxProxies() {
	m.max_proxies = nil
	m.addmax_proxies = nil
}

// SetActive sets the "active" field.
func (m *OrgMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *OrgMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *OrgMutation) ResetActive() {
	m.active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrgMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrgMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrgMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrgMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrgMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrgMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *OrgMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *OrgMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *OrgMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *OrgMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *OrgMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *OrgMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *OrgMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddProxyIDs adds the "proxies" edge to the Proxy entity by ids.
func (m *OrgMutation) AddProxyIDs(ids ...int) {
	if m.proxies == nil {
		m.proxies = make(map[int]struct{})
	}
	for i := range ids {
		m.proxies[ids[i]] = struct{}{}
	}
}

// ClearProxies clears the "proxies" edge to the Proxy entity.
func (m *OrgMutation) ClearProxies() {
	m.clearedproxies = true
}

// ProxiesCleared reports if the "proxies" edge to the Proxy entity was cleared.
func (m *OrgMutation) ProxiesCleared() bool {
	return m.clearedproxies
}

// RemoveProxyIDs removes the "proxies" edge to the Proxy entity by IDs.
func (m *OrgMutation) RemoveProxyIDs(ids ...int) {
	if m.removedproxies == nil {
		m.removedproxies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.proxies, ids[i])
		m.removedproxies[ids[i]] = struct{}{}
	}
}

// RemovedProxies returns the removed IDs of the "proxies" edge to the Proxy entity.
func (m *OrgMutation) RemovedProxiesIDs() (ids []int) {
	for id := range m.removedproxies {
		ids = append(ids, id)
	}
	return
}

// ProxiesIDs returns the "proxies" edge IDs in the mutation.
func (m *OrgMutation) ProxiesIDs() (ids []int) {
	for id := range m.proxies {
		ids = append(ids, id)
	}
	return
}

// ResetProxies resets all changes to the "proxies" edge.
func (m *OrgMutation) ResetProxies() {
	m.proxies = nil
	m.clearedproxies = false
	m.removedproxies = nil
}

// Where appends a list predicates to the OrgMutation builder.
func (m *OrgMutation) Where(ps ...predicate.Org) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Org, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Org).
func (m *OrgMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, org.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, org.FieldSlug)
	}
	if m.plan != nil {
		fields = append(fields, org.FieldPlan)
	}
	if m.traffic_retention_days != nil {
		fields = append(fields, org.FieldTrafficRetentionDays)
	}
	if m.max_proxies != nil {
		fields = append(fields, org.FieldMaxProxies)
	}
	if m.active != nil {
		fields = append(fields, org.FieldActive)
	}
	if m.created_at != nil {
		fields = append(fields, org.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, org.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case org.FieldName:
		return m.Name()
	case org.FieldSlug:
		return m.Slug()
	case org.FieldPlan:
		return m.Plan()
	case org.FieldTrafficRetentionDays:
		return m.TrafficRetentionDays()
	case org.FieldMaxProxies:
		return m.MaxProxies()
	case org.FieldActive:
		return m.Active()
	case org.FieldCreatedAt:
		return m.CreatedAt()
	case org.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case org.FieldName:
		return m.OldName(ctx)
	case org.FieldSlug:
		return m.OldSlug(ctx)
	case org.FieldPlan:
		return m.OldPlan(ctx)
	case org.FieldTrafficRetentionDays:
		return m.OldTrafficRetentionDays(ctx)
	case org.FieldMaxProxies:
		return m.OldMaxProxies(ctx)
	case org.FieldActive:
		return m.OldActive(ctx)
	case org.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case org.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Org field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgMutation) SetField(name string, value ent.Value) error {
	switch name {
	case org.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case org.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case org.FieldPlan:
		v, ok := value.(org.Plan)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlan(v)
		return nil
	case org.FieldTrafficRetentionDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrafficRetentionDays(v)
		return nil
	case org.FieldMaxProxies:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxProxies(v)
		return nil
	case org.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case org.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case org.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Org field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgMutation) AddedFields() []string {
	var fields []string
	if m.addtraffic_retention_days != nil {
		fields = append(fields, org.FieldTrafficRetentionDays)
	}
	if m.addmax_proxies != nil {
		fields = append(fields, org.FieldMaxProxies)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case org.FieldTrafficRetentionDays:
		return m.AddedTrafficRetentionDays()
	case org.FieldMaxProxies:
		return m.AddedMaxProxies()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgMutation) AddField(name string, value ent.Value) error {
	switch name {
	case org.FieldTrafficRetentionDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTrafficRetentionDays(v)
		return nil
	case org.FieldMaxProxies:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxProxies(v)
		return nil
	}
	return fmt.Errorf("unknown Org numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Org nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgMutation) ResetField(name string) error {
	switch name {
	case org.FieldName:
		m.ResetName()
		return nil
	case org.FieldSlug:
		m.ResetSlug()
		return nil
	case org.FieldPlan:
		m.ResetPlan()
		return nil
	case org.FieldTrafficRetentionDays:
		m.ResetTrafficRetentionDays()
		return nil
	case org.FieldMaxProxies:
		m.ResetMaxProxies()
		return nil
	case org.FieldActive:
		m.ResetActive()
		return nil
	case org.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case org.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Org field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, org.EdgeUsers)
	}
	if m.proxies != nil {
		edges = append(edges, org.EdgeProxies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case org.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case org.EdgeProxies:
		ids := make([]ent.Value, 0, len(m.proxies))
		for id := range m.proxies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, org.EdgeUsers)
	}
	if m.removedproxies != nil {
		edges = append(edges, org.EdgeProxies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case org.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case org.EdgeProxies:
		ids := make([]ent.Value, 0, len(m.removedproxies))
		for id := range m.removedproxies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, org.EdgeUsers)
	}
	if m.clearedproxies {
		edges = append(edges, org.EdgeProxies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgMutation) EdgeCleared(name string) bool {
	switch name {
	case org.EdgeUsers:
		return m.clearedusers
	case org.EdgeProxies:
		return m.clearedproxies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Org unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgMutation) ResetEdge(name string) error {
	switch name {
	case org.EdgeUsers:
		m.ResetUsers()
		return nil
	case org.EdgeProxies:
		m.ResetProxies()
		return nil
	}
	return fmt.Errorf("unknown Org edge %s", name)
}

// ProxyMutation represents an operation that mutates the Proxy nodes in the graph.
type ProxyMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	slug                *string
	mode                *proxy.Mode
	port                *int
	addport             *int
	host                *string
	mitm_enabled        *bool
	skip_hosts          *[]string
	appendskip_hosts    []string
	include_hosts       *[]string
	appendinclude_hosts []string
	exclude_hosts       *[]string
	appendexclude_hosts []string
	include_paths       *[]string
	appendinclude_paths []string
	exclude_paths       *[]string
	appendexclude_paths []string
	upstream            *string
	skip_binary         *bool
	active              *bool
	last_started_at     *time.Time
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	org                 *int
	clearedorg          bool
	traffic             map[int]struct{}
	removedtraffic      map[int]struct{}
	clearedtraffic      bool
	done                bool
	oldValue            func(context.Context) (*Proxy, error)
	predicates          []predicate.Proxy
}

var _ ent.Mutation = (*ProxyMutation)(nil)

// proxyOption allows management of the mutation configuration using functional options.
type proxyOption func(*ProxyMutation)

// newProxyMutation creates new mutation for the Proxy entity.
func newProxyMutation(c config, op Op, opts ...proxyOption) *ProxyMutation {
	m := &ProxyMutation{
		config:        c,
		op:            op,
		typ:           TypeProxy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProxyID sets the ID field of the mutation.
func withProxyID(id int) proxyOption {
	return func(m *ProxyMutation) {
		var (
			err   error
			once  sync.Once
			value *Proxy
		)
		m.oldValue = func(ctx context.Context) (*Proxy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Proxy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProxy sets the old Proxy of the mutation.
func withProxy(node *Proxy) proxyOption {
	return func(m *ProxyMutation) {
		m.oldValue = func(context.Context) (*Proxy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProxyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProxyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProxyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProxyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Proxy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProxyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProxyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProxyMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *ProxyMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *ProxyMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *ProxyMutation) ResetSlug() {
	m.slug = nil
}

// SetMode sets the "mode" field.
func (m *ProxyMutation) SetMode(pr proxy.Mode) {
	m.mode = &pr
}

// Mode returns the value of the "mode" field in the mutation.
func (m *ProxyMutation) Mode() (r proxy.Mode, exists bool) {
	v := m.mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMode returns the old "mode" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldMode(ctx context.Context) (v proxy.Mode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMode: %w", err)
	}
	return oldValue.Mode, nil
}

// ResetMode resets all changes to the "mode" field.
func (m *ProxyMutation) ResetMode() {
	m.mode = nil
}

// SetPort sets the "port" field.
func (m *ProxyMutation) SetPort(i int) {
	m.port = &i
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *ProxyMutation) Port() (r int, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to the "port" field.
func (m *ProxyMutation) AddPort(i int) {
	if m.addport != nil {
		*m.addport += i
	} else {
		m.addport = &i
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *ProxyMutation) AddedPort() (r int, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ResetPort resets all changes to the "port" field.
func (m *ProxyMutation) ResetPort() {
	m.port = nil
	m.addport = nil
}

// SetHost sets the "host" field.
func (m *ProxyMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *ProxyMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ResetHost resets all changes to the "host" field.
func (m *ProxyMutation) ResetHost() {
	m.host = nil
}

// SetMitmEnabled sets the "mitm_enabled" field.
func (m *ProxyMutation) SetMitmEnabled(b bool) {
	m.mitm_enabled = &b
}

// MitmEnabled returns the value of the "mitm_enabled" field in the mutation.
func (m *ProxyMutation) MitmEnabled() (r bool, exists bool) {
	v := m.mitm_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldMitmEnabled returns the old "mitm_enabled" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldMitmEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMitmEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMitmEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMitmEnabled: %w", err)
	}
	return oldValue.MitmEnabled, nil
}

// ResetMitmEnabled resets all changes to the "mitm_enabled" field.
func (m *ProxyMutation) ResetMitmEnabled() {
	m.mitm_enabled = nil
}

// SetSkipHosts sets the "skip_hosts" field.
func (m *ProxyMutation) SetSkipHosts(s []string) {
	m.skip_hosts = &s
	m.appendskip_hosts = nil
}

// SkipHosts returns the value of the "skip_hosts" field in the mutation.
func (m *ProxyMutation) SkipHosts() (r []string, exists bool) {
	v := m.skip_hosts
	if v == nil {
		return
	}
	return *v, true
}

// OldSkipHosts returns the old "skip_hosts" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldSkipHosts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkipHosts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkipHosts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkipHosts: %w", err)
	}
	return oldValue.SkipHosts, nil
}

// AppendSkipHosts adds s to the "skip_hosts" field.
func (m *ProxyMutation) AppendSkipHosts(s []string) {
	m.appendskip_hosts = append(m.appendskip_hosts, s...)
}

// AppendedSkipHosts returns the list of values that were appended to the "skip_hosts" field in this mutation.
func (m *ProxyMutation) AppendedSkipHosts() ([]string, bool) {
	if len(m.appendskip_hosts) == 0 {
		return nil, false
	}
	return m.appendskip_hosts, true
}

// ClearSkipHosts clears the value of the "skip_hosts" field.
func (m *ProxyMutation) ClearSkipHosts() {
	m.skip_hosts = nil
	m.appendskip_hosts = nil
	m.clearedFields[proxy.FieldSkipHosts] = struct{}{}
}

// SkipHostsCleared returns if the "skip_hosts" field was cleared in this mutation.
func (m *ProxyMutation) SkipHostsCleared() bool {
	_, ok := m.clearedFields[proxy.FieldSkipHosts]
	return ok
}

// ResetSkipHosts resets all changes to the "skip_hosts" field.
func (m *ProxyMutation) ResetSkipHosts() {
	m.skip_hosts = nil
	m.appendskip_hosts = nil
	delete(m.clearedFields, proxy.FieldSkipHosts)
}

// SetIncludeHosts sets the "include_hosts" field.
func (m *ProxyMutation) SetIncludeHosts(s []string) {
	m.include_hosts = &s
	m.appendinclude_hosts = nil
}

// IncludeHosts returns the value of the "include_hosts" field in the mutation.
func (m *ProxyMutation) IncludeHosts() (r []string, exists bool) {
	v := m.include_hosts
	if v == nil {
		return
	}
	return *v, true
}

// OldIncludeHosts returns the old "include_hosts" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldIncludeHosts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncludeHosts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncludeHosts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncludeHosts: %w", err)
	}
	return oldValue.IncludeHosts, nil
}

// AppendIncludeHosts adds s to the "include_hosts" field.
func (m *ProxyMutation) AppendIncludeHosts(s []string) {
	m.appendinclude_hosts = append(m.appendinclude_hosts, s...)
}

// AppendedIncludeHosts returns the list of values that were appended to the "include_hosts" field in this mutation.
func (m *ProxyMutation) AppendedIncludeHosts() ([]string, bool) {
	if len(m.appendinclude_hosts) == 0 {
		return nil, false
	}
	return m.appendinclude_hosts, true
}

// ClearIncludeHosts clears the value of the "include_hosts" field.
func (m *ProxyMutation) ClearIncludeHosts() {
	m.include_hosts = nil
	m.appendinclude_hosts = nil
	m.clearedFields[proxy.FieldIncludeHosts] = struct{}{}
}

// IncludeHostsCleared returns if the "include_hosts" field was cleared in this mutation.
func (m *ProxyMutation) IncludeHostsCleared() bool {
	_, ok := m.clearedFields[proxy.FieldIncludeHosts]
	return ok
}

// ResetIncludeHosts resets all changes to the "include_hosts" field.
func (m *ProxyMutation) ResetIncludeHosts() {
	m.include_hosts = nil
	m.appendinclude_hosts = nil
	delete(m.clearedFields, proxy.FieldIncludeHosts)
}

// SetExcludeHosts sets the "exclude_hosts" field.
func (m *ProxyMutation) SetExcludeHosts(s []string) {
	m.exclude_hosts = &s
	m.appendexclude_hosts = nil
}

// ExcludeHosts returns the value of the "exclude_hosts" field in the mutation.
func (m *ProxyMutation) ExcludeHosts() (r []string, exists bool) {
	v := m.exclude_hosts
	if v == nil {
		return
	}
	return *v, true
}

// OldExcludeHosts returns the old "exclude_hosts" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldExcludeHosts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcludeHosts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcludeHosts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcludeHosts: %w", err)
	}
	return oldValue.ExcludeHosts, nil
}

// AppendExcludeHosts adds s to the "exclude_hosts" field.
func (m *ProxyMutation) AppendExcludeHosts(s []string) {
	m.appendexclude_hosts = append(m.appendexclude_hosts, s...)
}

// AppendedExcludeHosts returns the list of values that were appended to the "exclude_hosts" field in this mutation.
func (m *ProxyMutation) AppendedExcludeHosts() ([]string, bool) {
	if len(m.appendexclude_hosts) == 0 {
		return nil, false
	}
	return m.appendexclude_hosts, true
}

// ClearExcludeHosts clears the value of the "exclude_hosts" field.
func (m *ProxyMutation) ClearExcludeHosts() {
	m.exclude_hosts = nil
	m.appendexclude_hosts = nil
	m.clearedFields[proxy.FieldExcludeHosts] = struct{}{}
}

// ExcludeHostsCleared returns if the "exclude_hosts" field was cleared in this mutation.
func (m *ProxyMutation) ExcludeHostsCleared() bool {
	_, ok := m.clearedFields[proxy.FieldExcludeHosts]
	return ok
}

// ResetExcludeHosts resets all changes to the "exclude_hosts" field.
func (m *ProxyMutation) ResetExcludeHosts() {
	m.exclude_hosts = nil
	m.appendexclude_hosts = nil
	delete(m.clearedFields, proxy.FieldExcludeHosts)
}

// SetIncludePaths sets the "include_paths" field.
func (m *ProxyMutation) SetIncludePaths(s []string) {
	m.include_paths = &s
	m.appendinclude_paths = nil
}

// IncludePaths returns the value of the "include_paths" field in the mutation.
func (m *ProxyMutation) IncludePaths() (r []string, exists bool) {
	v := m.include_paths
	if v == nil {
		return
	}
	return *v, true
}

// OldIncludePaths returns the old "include_paths" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldIncludePaths(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncludePaths is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncludePaths requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncludePaths: %w", err)
	}
	return oldValue.IncludePaths, nil
}

// AppendIncludePaths adds s to the "include_paths" field.
func (m *ProxyMutation) AppendIncludePaths(s []string) {
	m.appendinclude_paths = append(m.appendinclude_paths, s...)
}

// AppendedIncludePaths returns the list of values that were appended to the "include_paths" field in this mutation.
func (m *ProxyMutation) AppendedIncludePaths() ([]string, bool) {
	if len(m.appendinclude_paths) == 0 {
		return nil, false
	}
	return m.appendinclude_paths, true
}

// ClearIncludePaths clears the value of the "include_paths" field.
func (m *ProxyMutation) ClearIncludePaths() {
	m.include_paths = nil
	m.appendinclude_paths = nil
	m.clearedFields[proxy.FieldIncludePaths] = struct{}{}
}

// IncludePathsCleared returns if the "include_paths" field was cleared in this mutation.
func (m *ProxyMutation) IncludePathsCleared() bool {
	_, ok := m.clearedFields[proxy.FieldIncludePaths]
	return ok
}

// ResetIncludePaths resets all changes to the "include_paths" field.
func (m *ProxyMutation) ResetIncludePaths() {
	m.include_paths = nil
	m.appendinclude_paths = nil
	delete(m.clearedFields, proxy.FieldIncludePaths)
}

// SetExcludePaths sets the "exclude_paths" field.
func (m *ProxyMutation) SetExcludePaths(s []string) {
	m.exclude_paths = &s
	m.appendexclude_paths = nil
}

// ExcludePaths returns the value of the "exclude_paths" field in the mutation.
func (m *ProxyMutation) ExcludePaths() (r []string, exists bool) {
	v := m.exclude_paths
	if v == nil {
		return
	}
	return *v, true
}

// OldExcludePaths returns the old "exclude_paths" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldExcludePaths(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcludePaths is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcludePaths requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcludePaths: %w", err)
	}
	return oldValue.ExcludePaths, nil
}

// AppendExcludePaths adds s to the "exclude_paths" field.
func (m *ProxyMutation) AppendExcludePaths(s []string) {
	m.appendexclude_paths = append(m.appendexclude_paths, s...)
}

// AppendedExcludePaths returns the list of values that were appended to the "exclude_paths" field in this mutation.
func (m *ProxyMutation) AppendedExcludePaths() ([]string, bool) {
	if len(m.appendexclude_paths) == 0 {
		return nil, false
	}
	return m.appendexclude_paths, true
}

// ClearExcludePaths clears the value of the "exclude_paths" field.
func (m *ProxyMutation) ClearExcludePaths() {
	m.exclude_paths = nil
	m.appendexclude_paths = nil
	m.clearedFields[proxy.FieldExcludePaths] = struct{}{}
}

// ExcludePathsCleared returns if the "exclude_paths" field was cleared in this mutation.
func (m *ProxyMutation) ExcludePathsCleared() bool {
	_, ok := m.clearedFields[proxy.FieldExcludePaths]
	return ok
}

// ResetExcludePaths resets all changes to the "exclude_paths" field.
func (m *ProxyMutation) ResetExcludePaths() {
	m.exclude_paths = nil
	m.appendexclude_paths = nil
	delete(m.clearedFields, proxy.FieldExcludePaths)
}

// SetUpstream sets the "upstream" field.
func (m *ProxyMutation) SetUpstream(s string) {
	m.upstream = &s
}

// Upstream returns the value of the "upstream" field in the mutation.
func (m *ProxyMutation) Upstream() (r string, exists bool) {
	v := m.upstream
	if v == nil {
		return
	}
	return *v, true
}

// OldUpstream returns the old "upstream" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldUpstream(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpstream is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpstream requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpstream: %w", err)
	}
	return oldValue.Upstream, nil
}

// ClearUpstream clears the value of the "upstream" field.
func (m *ProxyMutation) ClearUpstream() {
	m.upstream = nil
	m.clearedFields[proxy.FieldUpstream] = struct{}{}
}

// UpstreamCleared returns if the "upstream" field was cleared in this mutation.
func (m *ProxyMutation) UpstreamCleared() bool {
	_, ok := m.clearedFields[proxy.FieldUpstream]
	return ok
}

// ResetUpstream resets all changes to the "upstream" field.
func (m *ProxyMutation) ResetUpstream() {
	m.upstream = nil
	delete(m.clearedFields, proxy.FieldUpstream)
}

// SetSkipBinary sets the "skip_binary" field.
func (m *ProxyMutation) SetSkipBinary(b bool) {
	m.skip_binary = &b
}

// SkipBinary returns the value of the "skip_binary" field in the mutation.
func (m *ProxyMutation) SkipBinary() (r bool, exists bool) {
	v := m.skip_binary
	if v == nil {
		return
	}
	return *v, true
}

// OldSkipBinary returns the old "skip_binary" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldSkipBinary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkipBinary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkipBinary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkipBinary: %w", err)
	}
	return oldValue.SkipBinary, nil
}

// ResetSkipBinary resets all changes to the "skip_binary" field.
func (m *ProxyMutation) ResetSkipBinary() {
	m.skip_binary = nil
}

// SetActive sets the "active" field.
func (m *ProxyMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *ProxyMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *ProxyMutation) ResetActive() {
	m.active = nil
}

// SetLastStartedAt sets the "last_started_at" field.
func (m *ProxyMutation) SetLastStartedAt(t time.Time) {
	m.last_started_at = &t
}

// LastStartedAt returns the value of the "last_started_at" field in the mutation.
func (m *ProxyMutation) LastStartedAt() (r time.Time, exists bool) {
	v := m.last_started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastStartedAt returns the old "last_started_at" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldLastStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastStartedAt: %w", err)
	}
	return oldValue.LastStartedAt, nil
}

// ClearLastStartedAt clears the value of the "last_started_at" field.
func (m *ProxyMutation) ClearLastStartedAt() {
	m.last_started_at = nil
	m.clearedFields[proxy.FieldLastStartedAt] = struct{}{}
}

// LastStartedAtCleared returns if the "last_started_at" field was cleared in this mutation.
func (m *ProxyMutation) LastStartedAtCleared() bool {
	_, ok := m.clearedFields[proxy.FieldLastStartedAt]
	return ok
}

// ResetLastStartedAt resets all changes to the "last_started_at" field.
func (m *ProxyMutation) ResetLastStartedAt() {
	m.last_started_at = nil
	delete(m.clearedFields, proxy.FieldLastStartedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProxyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProxyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProxyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProxyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProxyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProxyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrgID sets the "org" edge to the Org entity by id.
func (m *ProxyMutation) SetOrgID(id int) {
	m.org = &id
}

// ClearOrg clears the "org" edge to the Org entity.
func (m *ProxyMutation) ClearOrg() {
	m.clearedorg = true
}

// OrgCleared reports if the "org" edge to the Org entity was cleared.
func (m *ProxyMutation) OrgCleared() bool {
	return m.clearedorg
}

// OrgID returns the "org" edge ID in the mutation.
func (m *ProxyMutation) OrgID() (id int, exists bool) {
	if m.org != nil {
		return *m.org, true
	}
	return
}

// OrgIDs returns the "org" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrgID instead. It exists only for internal usage by the builders.
func (m *ProxyMutation) OrgIDs() (ids []int) {
	if id := m.org; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrg resets all changes to the "org" edge.
func (m *ProxyMutation) ResetOrg() {
	m.org = nil
	m.clearedorg = false
}

// AddTrafficIDs adds the "traffic" edge to the Traffic entity by ids.
func (m *ProxyMutation) AddTrafficIDs(ids ...int) {
	if m.traffic == nil {
		m.traffic = make(map[int]struct{})
	}
	for i := range ids {
		m.traffic[ids[i]] = struct{}{}
	}
}

// ClearTraffic clears the "traffic" edge to the Traffic entity.
func (m *ProxyMutation) ClearTraffic() {
	m.clearedtraffic = true
}

// TrafficCleared reports if the "traffic" edge to the Traffic entity was cleared.
func (m *ProxyMutation) TrafficCleared() bool {
	return m.clearedtraffic
}

// RemoveTrafficIDs removes the "traffic" edge to the Traffic entity by IDs.
func (m *ProxyMutation) RemoveTrafficIDs(ids ...int) {
	if m.removedtraffic == nil {
		m.removedtraffic = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.traffic, ids[i])
		m.removedtraffic[ids[i]] = struct{}{}
	}
}

// RemovedTraffic returns the removed IDs of the "traffic" edge to the Traffic entity.
func (m *ProxyMutation) RemovedTrafficIDs() (ids []int) {
	for id := range m.removedtraffic {
		ids = append(ids, id)
	}
	return
}

// TrafficIDs returns the "traffic" edge IDs in the mutation.
func (m *ProxyMutation) TrafficIDs() (ids []int) {
	for id := range m.traffic {
		ids = append(ids, id)
	}
	return
}

// ResetTraffic resets all changes to the "traffic" edge.
func (m *ProxyMutation) ResetTraffic() {
	m.traffic = nil
	m.clearedtraffic = false
	m.removedtraffic = nil
}

// Where appends a list predicates to the ProxyMutation builder.
func (m *ProxyMutation) Where(ps ...predicate.Proxy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProxyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProxyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Proxy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProxyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProxyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Proxy).
func (m *ProxyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProxyMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.name != nil {
		fields = append(fields, proxy.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, proxy.FieldSlug)
	}
	if m.mode != nil {
		fields = append(fields, proxy.FieldMode)
	}
	if m.port != nil {
		fields = append(fields, proxy.FieldPort)
	}
	if m.host != nil {
		fields = append(fields, proxy.FieldHost)
	}
	if m.mitm_enabled != nil {
		fields = append(fields, proxy.FieldMitmEnabled)
	}
	if m.skip_hosts != nil {
		fields = append(fields, proxy.FieldSkipHosts)
	}
	if m.include_hosts != nil {
		fields = append(fields, proxy.FieldIncludeHosts)
	}
	if m.exclude_hosts != nil {
		fields = append(fields, proxy.FieldExcludeHosts)
	}
	if m.include_paths != nil {
		fields = append(fields, proxy.FieldIncludePaths)
	}
	if m.exclude_paths != nil {
		fields = append(fields, proxy.FieldExcludePaths)
	}
	if m.upstream != nil {
		fields = append(fields, proxy.FieldUpstream)
	}
	if m.skip_binary != nil {
		fields = append(fields, proxy.FieldSkipBinary)
	}
	if m.active != nil {
		fields = append(fields, proxy.FieldActive)
	}
	if m.last_started_at != nil {
		fields = append(fields, proxy.FieldLastStartedAt)
	}
	if m.created_at != nil {
		fields = append(fields, proxy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, proxy.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProxyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case proxy.FieldName:
		return m.Name()
	case proxy.FieldSlug:
		return m.Slug()
	case proxy.FieldMode:
		return m.Mode()
	case proxy.FieldPort:
		return m.Port()
	case proxy.FieldHost:
		return m.Host()
	case proxy.FieldMitmEnabled:
		return m.MitmEnabled()
	case proxy.FieldSkipHosts:
		return m.SkipHosts()
	case proxy.FieldIncludeHosts:
		return m.IncludeHosts()
	case proxy.FieldExcludeHosts:
		return m.ExcludeHosts()
	case proxy.FieldIncludePaths:
		return m.IncludePaths()
	case proxy.FieldExcludePaths:
		return m.ExcludePaths()
	case proxy.FieldUpstream:
		return m.Upstream()
	case proxy.FieldSkipBinary:
		return m.SkipBinary()
	case proxy.FieldActive:
		return m.Active()
	case proxy.FieldLastStartedAt:
		return m.LastStartedAt()
	case proxy.FieldCreatedAt:
		return m.CreatedAt()
	case proxy.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProxyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case proxy.FieldName:
		return m.OldName(ctx)
	case proxy.FieldSlug:
		return m.OldSlug(ctx)
	case proxy.FieldMode:
		return m.OldMode(ctx)
	case proxy.FieldPort:
		return m.OldPort(ctx)
	case proxy.FieldHost:
		return m.OldHost(ctx)
	case proxy.FieldMitmEnabled:
		return m.OldMitmEnabled(ctx)
	case proxy.FieldSkipHosts:
		return m.OldSkipHosts(ctx)
	case proxy.FieldIncludeHosts:
		return m.OldIncludeHosts(ctx)
	case proxy.FieldExcludeHosts:
		return m.OldExcludeHosts(ctx)
	case proxy.FieldIncludePaths:
		return m.OldIncludePaths(ctx)
	case proxy.FieldExcludePaths:
		return m.OldExcludePaths(ctx)
	case proxy.FieldUpstream:
		return m.OldUpstream(ctx)
	case proxy.FieldSkipBinary:
		return m.OldSkipBinary(ctx)
	case proxy.FieldActive:
		return m.OldActive(ctx)
	case proxy.FieldLastStartedAt:
		return m.OldLastStartedAt(ctx)
	case proxy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case proxy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Proxy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProxyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case proxy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case proxy.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case proxy.FieldMode:
		v, ok := value.(proxy.Mode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMode(v)
		return nil
	case proxy.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case proxy.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case proxy.FieldMitmEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMitmEnabled(v)
		return nil
	case proxy.FieldSkipHosts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkipHosts(v)
		return nil
	case proxy.FieldIncludeHosts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncludeHosts(v)
		return nil
	case proxy.FieldExcludeHosts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcludeHosts(v)
		return nil
	case proxy.FieldIncludePaths:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncludePaths(v)
		return nil
	case proxy.FieldExcludePaths:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcludePaths(v)
		return nil
	case proxy.FieldUpstream:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpstream(v)
		return nil
	case proxy.FieldSkipBinary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkipBinary(v)
		return nil
	case proxy.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case proxy.FieldLastStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastStartedAt(v)
		return nil
	case proxy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case proxy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Proxy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProxyMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, proxy.FieldPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProxyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case proxy.FieldPort:
		return m.AddedPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProxyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case proxy.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	}
	return fmt.Errorf("unknown Proxy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProxyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(proxy.FieldSkipHosts) {
		fields = append(fields, proxy.FieldSkipHosts)
	}
	if m.FieldCleared(proxy.FieldIncludeHosts) {
		fields = append(fields, proxy.FieldIncludeHosts)
	}
	if m.FieldCleared(proxy.FieldExcludeHosts) {
		fields = append(fields, proxy.FieldExcludeHosts)
	}
	if m.FieldCleared(proxy.FieldIncludePaths) {
		fields = append(fields, proxy.FieldIncludePaths)
	}
	if m.FieldCleared(proxy.FieldExcludePaths) {
		fields = append(fields, proxy.FieldExcludePaths)
	}
	if m.FieldCleared(proxy.FieldUpstream) {
		fields = append(fields, proxy.FieldUpstream)
	}
	if m.FieldCleared(proxy.FieldLastStartedAt) {
		fields = append(fields, proxy.FieldLastStartedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProxyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProxyMutation) ClearField(name string) error {
	switch name {
	case proxy.FieldSkipHosts:
		m.ClearSkipHosts()
		return nil
	case proxy.FieldIncludeHosts:
		m.ClearIncludeHosts()
		return nil
	case proxy.FieldExcludeHosts:
		m.ClearExcludeHosts()
		return nil
	case proxy.FieldIncludePaths:
		m.ClearIncludePaths()
		return nil
	case proxy.FieldExcludePaths:
		m.ClearExcludePaths()
		return nil
	case proxy.FieldUpstream:
		m.ClearUpstream()
		return nil
	case proxy.FieldLastStartedAt:
		m.ClearLastStartedAt()
		return nil
	}
	return fmt.Errorf("unknown Proxy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProxyMutation) ResetField(name string) error {
	switch name {
	case proxy.FieldName:
		m.ResetName()
		return nil
	case proxy.FieldSlug:
		m.ResetSlug()
		return nil
	case proxy.FieldMode:
		m.ResetMode()
		return nil
	case proxy.FieldPort:
		m.ResetPort()
		return nil
	case proxy.FieldHost:
		m.ResetHost()
		return nil
	case proxy.FieldMitmEnabled:
		m.ResetMitmEnabled()
		return nil
	case proxy.FieldSkipHosts:
		m.ResetSkipHosts()
		return nil
	case proxy.FieldIncludeHosts:
		m.ResetIncludeHosts()
		return nil
	case proxy.FieldExcludeHosts:
		m.ResetExcludeHosts()
		return nil
	case proxy.FieldIncludePaths:
		m.ResetIncludePaths()
		return nil
	case proxy.FieldExcludePaths:
		m.ResetExcludePaths()
		return nil
	case proxy.FieldUpstream:
		m.ResetUpstream()
		return nil
	case proxy.FieldSkipBinary:
		m.ResetSkipBinary()
		return nil
	case proxy.FieldActive:
		m.ResetActive()
		return nil
	case proxy.FieldLastStartedAt:
		m.ResetLastStartedAt()
		return nil
	case proxy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case proxy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Proxy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProxyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.org != nil {
		edges = append(edges, proxy.EdgeOrg)
	}
	if m.traffic != nil {
		edges = append(edges, proxy.EdgeTraffic)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProxyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case proxy.EdgeOrg:
		if id := m.org; id != nil {
			return []ent.Value{*id}
		}
	case proxy.EdgeTraffic:
		ids := make([]ent.Value, 0, len(m.traffic))
		for id := range m.traffic {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProxyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtraffic != nil {
		edges = append(edges, proxy.EdgeTraffic)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProxyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case proxy.EdgeTraffic:
		ids := make([]ent.Value, 0, len(m.removedtraffic))
		for id := range m.removedtraffic {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProxyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorg {
		edges = append(edges, proxy.EdgeOrg)
	}
	if m.clearedtraffic {
		edges = append(edges, proxy.EdgeTraffic)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProxyMutation) EdgeCleared(name string) bool {
	switch name {
	case proxy.EdgeOrg:
		return m.clearedorg
	case proxy.EdgeTraffic:
		return m.clearedtraffic
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProxyMutation) ClearEdge(name string) error {
	switch name {
	case proxy.EdgeOrg:
		m.ClearOrg()
		return nil
	}
	return fmt.Errorf("unknown Proxy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProxyMutation) ResetEdge(name string) error {
	switch name {
	case proxy.EdgeOrg:
		m.ResetOrg()
		return nil
	case proxy.EdgeTraffic:
		m.ResetTraffic()
		return nil
	}
	return fmt.Errorf("unknown Proxy edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op             Op
	typ            string
	id             *int
	token          *string
	ip_address     *string
	user_agent     *string
	expires_at     *time.Time
	last_active_at *time.Time
	created_at     *time.Time
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Session, error)
	predicates     []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id int) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToken sets the "token" field.
func (m *SessionMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *SessionMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *SessionMutation) ResetToken() {
	m.token = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *SessionMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *SessionMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *SessionMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[session.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *SessionMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[session.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *SessionMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, session.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *SessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *SessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *SessionMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[session.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *SessionMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[session.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *SessionMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, session.FieldUserAgent)
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetLastActiveAt sets the "last_active_at" field.
func (m *SessionMutation) SetLastActiveAt(t time.Time) {
	m.last_active_at = &t
}

// LastActiveAt returns the value of the "last_active_at" field in the mutation.
func (m *SessionMutation) LastActiveAt() (r time.Time, exists bool) {
	v := m.last_active_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastActiveAt returns the old "last_active_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldLastActiveAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastActiveAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastActiveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastActiveAt: %w", err)
	}
	return oldValue.LastActiveAt, nil
}

// ResetLastActiveAt resets all changes to the "last_active_at" field.
func (m *SessionMutation) ResetLastActiveAt() {
	m.last_active_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *SessionMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *SessionMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.token != nil {
		fields = append(fields, session.FieldToken)
	}
	if m.ip_address != nil {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	if m.last_active_at != nil {
		fields = append(fields, session.FieldLastActiveAt)
	}
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldToken:
		return m.Token()
	case session.FieldIPAddress:
		return m.IPAddress()
	case session.FieldUserAgent:
		return m.UserAgent()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	case session.FieldLastActiveAt:
		return m.LastActiveAt()
	case session.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldToken:
		return m.OldToken(ctx)
	case session.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case session.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case session.FieldLastActiveAt:
		return m.OldLastActiveAt(ctx)
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case session.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case session.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case session.FieldLastActiveAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastActiveAt(v)
		return nil
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldIPAddress) {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.FieldCleared(session.FieldUserAgent) {
		fields = append(fields, session.FieldUserAgent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case session.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldToken:
		m.ResetToken()
		return nil
	case session.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case session.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case session.FieldLastActiveAt:
		m.ResetLastActiveAt()
		return nil
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// TrafficMutation represents an operation that mutates the Traffic nodes in the graph.
type TrafficMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	method                *string
	url                   *string
	scheme                *string
	host                  *string
	_path                 *string
	query                 *string
	request_headers       *map[string][]string
	request_body          *[]byte
	request_body_size     *int64
	addrequest_body_size  *int64
	request_is_binary     *bool
	content_type          *string
	status_code           *int
	addstatus_code        *int
	status_text           *string
	response_headers      *map[string][]string
	response_body         *[]byte
	response_body_size    *int64
	addresponse_body_size *int64
	response_is_binary    *bool
	response_content_type *string
	started_at            *time.Time
	duration_ms           *float64
	addduration_ms        *float64
	ttfb_ms               *float64
	addttfb_ms            *float64
	client_ip             *string
	error                 *string
	tags                  *[]string
	appendtags            []string
	created_at            *time.Time
	clearedFields         map[string]struct{}
	proxy                 *int
	clearedproxy          bool
	done                  bool
	oldValue              func(context.Context) (*Traffic, error)
	predicates            []predicate.Traffic
}

var _ ent.Mutation = (*TrafficMutation)(nil)

// trafficOption allows management of the mutation configuration using functional options.
type trafficOption func(*TrafficMutation)

// newTrafficMutation creates new mutation for the Traffic entity.
func newTrafficMutation(c config, op Op, opts ...trafficOption) *TrafficMutation {
	m := &TrafficMutation{
		config:        c,
		op:            op,
		typ:           TypeTraffic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrafficID sets the ID field of the mutation.
func withTrafficID(id int) trafficOption {
	return func(m *TrafficMutation) {
		var (
			err   error
			once  sync.Once
			value *Traffic
		)
		m.oldValue = func(ctx context.Context) (*Traffic, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Traffic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTraffic sets the old Traffic of the mutation.
func withTraffic(node *Traffic) trafficOption {
	return func(m *TrafficMutation) {
		m.oldValue = func(context.Context) (*Traffic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrafficMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrafficMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrafficMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TrafficMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Traffic.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMethod sets the "method" field.
func (m *TrafficMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *TrafficMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *TrafficMutation) ResetMethod() {
	m.method = nil
}

// SetURL sets the "url" field.
func (m *TrafficMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *TrafficMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *TrafficMutation) ResetURL() {
	m.url = nil
}

// SetScheme sets the "scheme" field.
func (m *TrafficMutation) SetScheme(s string) {
	m.scheme = &s
}

// Scheme returns the value of the "scheme" field in the mutation.
func (m *TrafficMutation) Scheme() (r string, exists bool) {
	v := m.scheme
	if v == nil {
		return
	}
	return *v, true
}

// OldScheme returns the old "scheme" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldScheme(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheme: %w", err)
	}
	return oldValue.Scheme, nil
}

// ResetScheme resets all changes to the "scheme" field.
func (m *TrafficMutation) ResetScheme() {
	m.scheme = nil
}

// SetHost sets the "host" field.
func (m *TrafficMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *TrafficMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ResetHost resets all changes to the "host" field.
func (m *TrafficMutation) ResetHost() {
	m.host = nil
}

// SetPath sets the "path" field.
func (m *TrafficMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *TrafficMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *TrafficMutation) ResetPath() {
	m._path = nil
}

// SetQuery sets the "query" field.
func (m *TrafficMutation) SetQuery(s string) {
	m.query = &s
}

// Query returns the value of the "query" field in the mutation.
func (m *TrafficMutation) Query() (r string, exists bool) {
	v := m.query
	if v == nil {
		return
	}
	return *v, true
}

// OldQuery returns the old "query" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldQuery(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuery: %w", err)
	}
	return oldValue.Query, nil
}

// ClearQuery clears the value of the "query" field.
func (m *TrafficMutation) ClearQuery() {
	m.query = nil
	m.clearedFields[traffic.FieldQuery] = struct{}{}
}

// QueryCleared returns if the "query" field was cleared in this mutation.
func (m *TrafficMutation) QueryCleared() bool {
	_, ok := m.clearedFields[traffic.FieldQuery]
	return ok
}

// ResetQuery resets all changes to the "query" field.
func (m *TrafficMutation) ResetQuery() {
	m.query = nil
	delete(m.clearedFields, traffic.FieldQuery)
}

// SetRequestHeaders sets the "request_headers" field.
func (m *TrafficMutation) SetRequestHeaders(value map[string][]string) {
	m.request_headers = &value
}

// RequestHeaders returns the value of the "request_headers" field in the mutation.
func (m *TrafficMutation) RequestHeaders() (r map[string][]string, exists bool) {
	v := m.request_headers
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestHeaders returns the old "request_headers" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldRequestHeaders(ctx context.Context) (v map[string][]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestHeaders: %w", err)
	}
	return oldValue.RequestHeaders, nil
}

// ClearRequestHeaders clears the value of the "request_headers" field.
func (m *TrafficMutation) ClearRequestHeaders() {
	m.request_headers = nil
	m.clearedFields[traffic.FieldRequestHeaders] = struct{}{}
}

// RequestHeadersCleared returns if the "request_headers" field was cleared in this mutation.
func (m *TrafficMutation) RequestHeadersCleared() bool {
	_, ok := m.clearedFields[traffic.FieldRequestHeaders]
	return ok
}

// ResetRequestHeaders resets all changes to the "request_headers" field.
func (m *TrafficMutation) ResetRequestHeaders() {
	m.request_headers = nil
	delete(m.clearedFields, traffic.FieldRequestHeaders)
}

// SetRequestBody sets the "request_body" field.
func (m *TrafficMutation) SetRequestBody(b []byte) {
	m.request_body = &b
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *TrafficMutation) RequestBody() (r []byte, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldRequestBody(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// ClearRequestBody clears the value of the "request_body" field.
func (m *TrafficMutation) ClearRequestBody() {
	m.request_body = nil
	m.clearedFields[traffic.FieldRequestBody] = struct{}{}
}

// RequestBodyCleared returns if the "request_body" field was cleared in this mutation.
func (m *TrafficMutation) RequestBodyCleared() bool {
	_, ok := m.clearedFields[traffic.FieldRequestBody]
	return ok
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *TrafficMutation) ResetRequestBody() {
	m.request_body = nil
	delete(m.clearedFields, traffic.FieldRequestBody)
}

// SetRequestBodySize sets the "request_body_size" field.
func (m *TrafficMutation) SetRequestBodySize(i int64) {
	m.request_body_size = &i
	m.addrequest_body_size = nil
}

// RequestBodySize returns the value of the "request_body_size" field in the mutation.
func (m *TrafficMutation) RequestBodySize() (r int64, exists bool) {
	v := m.request_body_size
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBodySize returns the old "request_body_size" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldRequestBodySize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBodySize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBodySize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBodySize: %w", err)
	}
	return oldValue.RequestBodySize, nil
}

// AddRequestBodySize adds i to the "request_body_size" field.
func (m *TrafficMutation) AddRequestBodySize(i int64) {
	if m.addrequest_body_size != nil {
		*m.addrequest_body_size += i
	} else {
		m.addrequest_body_size = &i
	}
}

// AddedRequestBodySize returns the value that was added to the "request_body_size" field in this mutation.
func (m *TrafficMutation) AddedRequestBodySize() (r int64, exists bool) {
	v := m.addrequest_body_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetRequestBodySize resets all changes to the "request_body_size" field.
func (m *TrafficMutation) ResetRequestBodySize() {
	m.request_body_size = nil
	m.addrequest_body_size = nil
}

// SetRequestIsBinary sets the "request_is_binary" field.
func (m *TrafficMutation) SetRequestIsBinary(b bool) {
	m.request_is_binary = &b
}

// RequestIsBinary returns the value of the "request_is_binary" field in the mutation.
func (m *TrafficMutation) RequestIsBinary() (r bool, exists bool) {
	v := m.request_is_binary
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestIsBinary returns the old "request_is_binary" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldRequestIsBinary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestIsBinary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestIsBinary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestIsBinary: %w", err)
	}
	return oldValue.RequestIsBinary, nil
}

// ResetRequestIsBinary resets all changes to the "request_is_binary" field.
func (m *TrafficMutation) ResetRequestIsBinary() {
	m.request_is_binary = nil
}

// SetContentType sets the "content_type" field.
func (m *TrafficMutation) SetContentType(s string) {
	m.content_type = &s
}

// ContentType returns the value of the "content_type" field in the mutation.
func (m *TrafficMutation) ContentType() (r string, exists bool) {
	v := m.content_type
	if v == nil {
		return
	}
	return *v, true
}

// OldContentType returns the old "content_type" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldContentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentType: %w", err)
	}
	return oldValue.ContentType, nil
}

// ClearContentType clears the value of the "content_type" field.
func (m *TrafficMutation) ClearContentType() {
	m.content_type = nil
	m.clearedFields[traffic.FieldContentType] = struct{}{}
}

// ContentTypeCleared returns if the "content_type" field was cleared in this mutation.
func (m *TrafficMutation) ContentTypeCleared() bool {
	_, ok := m.clearedFields[traffic.FieldContentType]
	return ok
}

// ResetContentType resets all changes to the "content_type" field.
func (m *TrafficMutation) ResetContentType() {
	m.content_type = nil
	delete(m.clearedFields, traffic.FieldContentType)
}

// SetStatusCode sets the "status_code" field.
func (m *TrafficMutation) SetStatusCode(i int) {
	m.status_code = &i
	m.addstatus_code = nil
}

// StatusCode returns the value of the "status_code" field in the mutation.
func (m *TrafficMutation) StatusCode() (r int, exists bool) {
	v := m.status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCode returns the old "status_code" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldStatusCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCode: %w", err)
	}
	return oldValue.StatusCode, nil
}

// AddStatusCode adds i to the "status_code" field.
func (m *TrafficMutation) AddStatusCode(i int) {
	if m.addstatus_code != nil {
		*m.addstatus_code += i
	} else {
		m.addstatus_code = &i
	}
}

// AddedStatusCode returns the value that was added to the "status_code" field in this mutation.
func (m *TrafficMutation) AddedStatusCode() (r int, exists bool) {
	v := m.addstatus_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatusCode resets all changes to the "status_code" field.
func (m *TrafficMutation) ResetStatusCode() {
	m.status_code = nil
	m.addstatus_code = nil
}

// SetStatusText sets the "status_text" field.
func (m *TrafficMutation) SetStatusText(s string) {
	m.status_text = &s
}

// StatusText returns the value of the "status_text" field in the mutation.
func (m *TrafficMutation) StatusText() (r string, exists bool) {
	v := m.status_text
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusText returns the old "status_text" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldStatusText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusText: %w", err)
	}
	return oldValue.StatusText, nil
}

// ClearStatusText clears the value of the "status_text" field.
func (m *TrafficMutation) ClearStatusText() {
	m.status_text = nil
	m.clearedFields[traffic.FieldStatusText] = struct{}{}
}

// StatusTextCleared returns if the "status_text" field was cleared in this mutation.
func (m *TrafficMutation) StatusTextCleared() bool {
	_, ok := m.clearedFields[traffic.FieldStatusText]
	return ok
}

// ResetStatusText resets all changes to the "status_text" field.
func (m *TrafficMutation) ResetStatusText() {
	m.status_text = nil
	delete(m.clearedFields, traffic.FieldStatusText)
}

// SetResponseHeaders sets the "response_headers" field.
func (m *TrafficMutation) SetResponseHeaders(value map[string][]string) {
	m.response_headers = &value
}

// ResponseHeaders returns the value of the "response_headers" field in the mutation.
func (m *TrafficMutation) ResponseHeaders() (r map[string][]string, exists bool) {
	v := m.response_headers
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseHeaders returns the old "response_headers" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldResponseHeaders(ctx context.Context) (v map[string][]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseHeaders: %w", err)
	}
	return oldValue.ResponseHeaders, nil
}

// ClearResponseHeaders clears the value of the "response_headers" field.
func (m *TrafficMutation) ClearResponseHeaders() {
	m.response_headers = nil
	m.clearedFields[traffic.FieldResponseHeaders] = struct{}{}
}

// ResponseHeadersCleared returns if the "response_headers" field was cleared in this mutation.
func (m *TrafficMutation) ResponseHeadersCleared() bool {
	_, ok := m.clearedFields[traffic.FieldResponseHeaders]
	return ok
}

// ResetResponseHeaders resets all changes to the "response_headers" field.
func (m *TrafficMutation) ResetResponseHeaders() {
	m.response_headers = nil
	delete(m.clearedFields, traffic.FieldResponseHeaders)
}

// SetResponseBody sets the "response_body" field.
func (m *TrafficMutation) SetResponseBody(b []byte) {
	m.response_body = &b
}

// ResponseBody returns the value of the "response_body" field in the mutation.
func (m *TrafficMutation) ResponseBody() (r []byte, exists bool) {
	v := m.response_body
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseBody returns the old "response_body" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldResponseBody(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseBody: %w", err)
	}
	return oldValue.ResponseBody, nil
}

// ClearResponseBody clears the value of the "response_body" field.
func (m *TrafficMutation) ClearResponseBody() {
	m.response_body = nil
	m.clearedFields[traffic.FieldResponseBody] = struct{}{}
}

// ResponseBodyCleared returns if the "response_body" field was cleared in this mutation.
func (m *TrafficMutation) ResponseBodyCleared() bool {
	_, ok := m.clearedFields[traffic.FieldResponseBody]
	return ok
}

// ResetResponseBody resets all changes to the "response_body" field.
func (m *TrafficMutation) ResetResponseBody() {
	m.response_body = nil
	delete(m.clearedFields, traffic.FieldResponseBody)
}

// SetResponseBodySize sets the "response_body_size" field.
func (m *TrafficMutation) SetResponseBodySize(i int64) {
	m.response_body_size = &i
	m.addresponse_body_size = nil
}

// ResponseBodySize returns the value of the "response_body_size" field in the mutation.
func (m *TrafficMutation) ResponseBodySize() (r int64, exists bool) {
	v := m.response_body_size
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseBodySize returns the old "response_body_size" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldResponseBodySize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseBodySize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseBodySize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseBodySize: %w", err)
	}
	return oldValue.ResponseBodySize, nil
}

// AddResponseBodySize adds i to the "response_body_size" field.
func (m *TrafficMutation) AddResponseBodySize(i int64) {
	if m.addresponse_body_size != nil {
		*m.addresponse_body_size += i
	} else {
		m.addresponse_body_size = &i
	}
}

// AddedResponseBodySize returns the value that was added to the "response_body_size" field in this mutation.
func (m *TrafficMutation) AddedResponseBodySize() (r int64, exists bool) {
	v := m.addresponse_body_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetResponseBodySize resets all changes to the "response_body_size" field.
func (m *TrafficMutation) ResetResponseBodySize() {
	m.response_body_size = nil
	m.addresponse_body_size = nil
}

// SetResponseIsBinary sets the "response_is_binary" field.
func (m *TrafficMutation) SetResponseIsBinary(b bool) {
	m.response_is_binary = &b
}

// ResponseIsBinary returns the value of the "response_is_binary" field in the mutation.
func (m *TrafficMutation) ResponseIsBinary() (r bool, exists bool) {
	v := m.response_is_binary
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseIsBinary returns the old "response_is_binary" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldResponseIsBinary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseIsBinary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseIsBinary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseIsBinary: %w", err)
	}
	return oldValue.ResponseIsBinary, nil
}

// ResetResponseIsBinary resets all changes to the "response_is_binary" field.
func (m *TrafficMutation) ResetResponseIsBinary() {
	m.response_is_binary = nil
}

// SetResponseContentType sets the "response_content_type" field.
func (m *TrafficMutation) SetResponseContentType(s string) {
	m.response_content_type = &s
}

// ResponseContentType returns the value of the "response_content_type" field in the mutation.
func (m *TrafficMutation) ResponseContentType() (r string, exists bool) {
	v := m.response_content_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseContentType returns the old "response_content_type" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldResponseContentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseContentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseContentType: %w", err)
	}
	return oldValue.ResponseContentType, nil
}

// ClearResponseContentType clears the value of the "response_content_type" field.
func (m *TrafficMutation) ClearResponseContentType() {
	m.response_content_type = nil
	m.clearedFields[traffic.FieldResponseContentType] = struct{}{}
}

// ResponseContentTypeCleared returns if the "response_content_type" field was cleared in this mutation.
func (m *TrafficMutation) ResponseContentTypeCleared() bool {
	_, ok := m.clearedFields[traffic.FieldResponseContentType]
	return ok
}

// ResetResponseContentType resets all changes to the "response_content_type" field.
func (m *TrafficMutation) ResetResponseContentType() {
	m.response_content_type = nil
	delete(m.clearedFields, traffic.FieldResponseContentType)
}

// SetStartedAt sets the "started_at" field.
func (m *TrafficMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *TrafficMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *TrafficMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetDurationMs sets the "duration_ms" field.
func (m *TrafficMutation) SetDurationMs(f float64) {
	m.duration_ms = &f
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *TrafficMutation) DurationMs() (r float64, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldDurationMs(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds f to the "duration_ms" field.
func (m *TrafficMutation) AddDurationMs(f float64) {
	if m.addduration_ms != nil {
		*m.addduration_ms += f
	} else {
		m.addduration_ms = &f
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *TrafficMutation) AddedDurationMs() (r float64, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *TrafficMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
}

// SetTtfbMs sets the "ttfb_ms" field.
func (m *TrafficMutation) SetTtfbMs(f float64) {
	m.ttfb_ms = &f
	m.addttfb_ms = nil
}

// TtfbMs returns the value of the "ttfb_ms" field in the mutation.
func (m *TrafficMutation) TtfbMs() (r float64, exists bool) {
	v := m.ttfb_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldTtfbMs returns the old "ttfb_ms" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldTtfbMs(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTtfbMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTtfbMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTtfbMs: %w", err)
	}
	return oldValue.TtfbMs, nil
}

// AddTtfbMs adds f to the "ttfb_ms" field.
func (m *TrafficMutation) AddTtfbMs(f float64) {
	if m.addttfb_ms != nil {
		*m.addttfb_ms += f
	} else {
		m.addttfb_ms = &f
	}
}

// AddedTtfbMs returns the value that was added to the "ttfb_ms" field in this mutation.
func (m *TrafficMutation) AddedTtfbMs() (r float64, exists bool) {
	v := m.addttfb_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearTtfbMs clears the value of the "ttfb_ms" field.
func (m *TrafficMutation) ClearTtfbMs() {
	m.ttfb_ms = nil
	m.addttfb_ms = nil
	m.clearedFields[traffic.FieldTtfbMs] = struct{}{}
}

// TtfbMsCleared returns if the "ttfb_ms" field was cleared in this mutation.
func (m *TrafficMutation) TtfbMsCleared() bool {
	_, ok := m.clearedFields[traffic.FieldTtfbMs]
	return ok
}

// ResetTtfbMs resets all changes to the "ttfb_ms" field.
func (m *TrafficMutation) ResetTtfbMs() {
	m.ttfb_ms = nil
	m.addttfb_ms = nil
	delete(m.clearedFields, traffic.FieldTtfbMs)
}

// SetClientIP sets the "client_ip" field.
func (m *TrafficMutation) SetClientIP(s string) {
	m.client_ip = &s
}

// ClientIP returns the value of the "client_ip" field in the mutation.
func (m *TrafficMutation) ClientIP() (r string, exists bool) {
	v := m.client_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldClientIP returns the old "client_ip" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldClientIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientIP: %w", err)
	}
	return oldValue.ClientIP, nil
}

// ClearClientIP clears the value of the "client_ip" field.
func (m *TrafficMutation) ClearClientIP() {
	m.client_ip = nil
	m.clearedFields[traffic.FieldClientIP] = struct{}{}
}

// ClientIPCleared returns if the "client_ip" field was cleared in this mutation.
func (m *TrafficMutation) ClientIPCleared() bool {
	_, ok := m.clearedFields[traffic.FieldClientIP]
	return ok
}

// ResetClientIP resets all changes to the "client_ip" field.
func (m *TrafficMutation) ResetClientIP() {
	m.client_ip = nil
	delete(m.clearedFields, traffic.FieldClientIP)
}

// SetError sets the "error" field.
func (m *TrafficMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *TrafficMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *TrafficMutation) ClearError() {
	m.error = nil
	m.clearedFields[traffic.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *TrafficMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[traffic.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *TrafficMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, traffic.FieldError)
}

// SetTags sets the "tags" field.
func (m *TrafficMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *TrafficMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *TrafficMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *TrafficMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *TrafficMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[traffic.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *TrafficMutation) TagsCleared() bool {
	_, ok := m.clearedFields[traffic.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *TrafficMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, traffic.FieldTags)
}

// SetCreatedAt sets the "created_at" field.
func (m *TrafficMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TrafficMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Traffic entity.
// If the Traffic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrafficMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TrafficMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetProxyID sets the "proxy" edge to the Proxy entity by id.
func (m *TrafficMutation) SetProxyID(id int) {
	m.proxy = &id
}

// ClearProxy clears the "proxy" edge to the Proxy entity.
func (m *TrafficMutation) ClearProxy() {
	m.clearedproxy = true
}

// ProxyCleared reports if the "proxy" edge to the Proxy entity was cleared.
func (m *TrafficMutation) ProxyCleared() bool {
	return m.clearedproxy
}

// ProxyID returns the "proxy" edge ID in the mutation.
func (m *TrafficMutation) ProxyID() (id int, exists bool) {
	if m.proxy != nil {
		return *m.proxy, true
	}
	return
}

// ProxyIDs returns the "proxy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProxyID instead. It exists only for internal usage by the builders.
func (m *TrafficMutation) ProxyIDs() (ids []int) {
	if id := m.proxy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProxy resets all changes to the "proxy" edge.
func (m *TrafficMutation) ResetProxy() {
	m.proxy = nil
	m.clearedproxy = false
}

// Where appends a list predicates to the TrafficMutation builder.
func (m *TrafficMutation) Where(ps ...predicate.Traffic) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TrafficMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TrafficMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Traffic, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TrafficMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TrafficMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Traffic).
func (m *TrafficMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrafficMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.method != nil {
		fields = append(fields, traffic.FieldMethod)
	}
	if m.url != nil {
		fields = append(fields, traffic.FieldURL)
	}
	if m.scheme != nil {
		fields = append(fields, traffic.FieldScheme)
	}
	if m.host != nil {
		fields = append(fields, traffic.FieldHost)
	}
	if m._path != nil {
		fields = append(fields, traffic.FieldPath)
	}
	if m.query != nil {
		fields = append(fields, traffic.FieldQuery)
	}
	if m.request_headers != nil {
		fields = append(fields, traffic.FieldRequestHeaders)
	}
	if m.request_body != nil {
		fields = append(fields, traffic.FieldRequestBody)
	}
	if m.request_body_size != nil {
		fields = append(fields, traffic.FieldRequestBodySize)
	}
	if m.request_is_binary != nil {
		fields = append(fields, traffic.FieldRequestIsBinary)
	}
	if m.content_type != nil {
		fields = append(fields, traffic.FieldContentType)
	}
	if m.status_code != nil {
		fields = append(fields, traffic.FieldStatusCode)
	}
	if m.status_text != nil {
		fields = append(fields, traffic.FieldStatusText)
	}
	if m.response_headers != nil {
		fields = append(fields, traffic.FieldResponseHeaders)
	}
	if m.response_body != nil {
		fields = append(fields, traffic.FieldResponseBody)
	}
	if m.response_body_size != nil {
		fields = append(fields, traffic.FieldResponseBodySize)
	}
	if m.response_is_binary != nil {
		fields = append(fields, traffic.FieldResponseIsBinary)
	}
	if m.response_content_type != nil {
		fields = append(fields, traffic.FieldResponseContentType)
	}
	if m.started_at != nil {
		fields = append(fields, traffic.FieldStartedAt)
	}
	if m.duration_ms != nil {
		fields = append(fields, traffic.FieldDurationMs)
	}
	if m.ttfb_ms != nil {
		fields = append(fields, traffic.FieldTtfbMs)
	}
	if m.client_ip != nil {
		fields = append(fields, traffic.FieldClientIP)
	}
	if m.error != nil {
		fields = append(fields, traffic.FieldError)
	}
	if m.tags != nil {
		fields = append(fields, traffic.FieldTags)
	}
	if m.created_at != nil {
		fields = append(fields, traffic.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrafficMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case traffic.FieldMethod:
		return m.Method()
	case traffic.FieldURL:
		return m.URL()
	case traffic.FieldScheme:
		return m.Scheme()
	case traffic.FieldHost:
		return m.Host()
	case traffic.FieldPath:
		return m.Path()
	case traffic.FieldQuery:
		return m.Query()
	case traffic.FieldRequestHeaders:
		return m.RequestHeaders()
	case traffic.FieldRequestBody:
		return m.RequestBody()
	case traffic.FieldRequestBodySize:
		return m.RequestBodySize()
	case traffic.FieldRequestIsBinary:
		return m.RequestIsBinary()
	case traffic.FieldContentType:
		return m.ContentType()
	case traffic.FieldStatusCode:
		return m.StatusCode()
	case traffic.FieldStatusText:
		return m.StatusText()
	case traffic.FieldResponseHeaders:
		return m.ResponseHeaders()
	case traffic.FieldResponseBody:
		return m.ResponseBody()
	case traffic.FieldResponseBodySize:
		return m.ResponseBodySize()
	case traffic.FieldResponseIsBinary:
		return m.ResponseIsBinary()
	case traffic.FieldResponseContentType:
		return m.ResponseContentType()
	case traffic.FieldStartedAt:
		return m.StartedAt()
	case traffic.FieldDurationMs:
		return m.DurationMs()
	case traffic.FieldTtfbMs:
		return m.TtfbMs()
	case traffic.FieldClientIP:
		return m.ClientIP()
	case traffic.FieldError:
		return m.Error()
	case traffic.FieldTags:
		return m.Tags()
	case traffic.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrafficMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case traffic.FieldMethod:
		return m.OldMethod(ctx)
	case traffic.FieldURL:
		return m.OldURL(ctx)
	case traffic.FieldScheme:
		return m.OldScheme(ctx)
	case traffic.FieldHost:
		return m.OldHost(ctx)
	case traffic.FieldPath:
		return m.OldPath(ctx)
	case traffic.FieldQuery:
		return m.OldQuery(ctx)
	case traffic.FieldRequestHeaders:
		return m.OldRequestHeaders(ctx)
	case traffic.FieldRequestBody:
		return m.OldRequestBody(ctx)
	case traffic.FieldRequestBodySize:
		return m.OldRequestBodySize(ctx)
	case traffic.FieldRequestIsBinary:
		return m.OldRequestIsBinary(ctx)
	case traffic.FieldContentType:
		return m.OldContentType(ctx)
	case traffic.FieldStatusCode:
		return m.OldStatusCode(ctx)
	case traffic.FieldStatusText:
		return m.OldStatusText(ctx)
	case traffic.FieldResponseHeaders:
		return m.OldResponseHeaders(ctx)
	case traffic.FieldResponseBody:
		return m.OldResponseBody(ctx)
	case traffic.FieldResponseBodySize:
		return m.OldResponseBodySize(ctx)
	case traffic.FieldResponseIsBinary:
		return m.OldResponseIsBinary(ctx)
	case traffic.FieldResponseContentType:
		return m.OldResponseContentType(ctx)
	case traffic.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case traffic.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case traffic.FieldTtfbMs:
		return m.OldTtfbMs(ctx)
	case traffic.FieldClientIP:
		return m.OldClientIP(ctx)
	case traffic.FieldError:
		return m.OldError(ctx)
	case traffic.FieldTags:
		return m.OldTags(ctx)
	case traffic.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Traffic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrafficMutation) SetField(name string, value ent.Value) error {
	switch name {
	case traffic.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case traffic.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case traffic.FieldScheme:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheme(v)
		return nil
	case traffic.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case traffic.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case traffic.FieldQuery:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuery(v)
		return nil
	case traffic.FieldRequestHeaders:
		v, ok := value.(map[string][]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestHeaders(v)
		return nil
	case traffic.FieldRequestBody:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	case traffic.FieldRequestBodySize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBodySize(v)
		return nil
	case traffic.FieldRequestIsBinary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestIsBinary(v)
		return nil
	case traffic.FieldContentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentType(v)
		return nil
	case traffic.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCode(v)
		return nil
	case traffic.FieldStatusText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusText(v)
		return nil
	case traffic.FieldResponseHeaders:
		v, ok := value.(map[string][]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseHeaders(v)
		return nil
	case traffic.FieldResponseBody:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseBody(v)
		return nil
	case traffic.FieldResponseBodySize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseBodySize(v)
		return nil
	case traffic.FieldResponseIsBinary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseIsBinary(v)
		return nil
	case traffic.FieldResponseContentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseContentType(v)
		return nil
	case traffic.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case traffic.FieldDurationMs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case traffic.FieldTtfbMs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTtfbMs(v)
		return nil
	case traffic.FieldClientIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientIP(v)
		return nil
	case traffic.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case traffic.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case traffic.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Traffic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrafficMutation) AddedFields() []string {
	var fields []string
	if m.addrequest_body_size != nil {
		fields = append(fields, traffic.FieldRequestBodySize)
	}
	if m.addstatus_code != nil {
		fields = append(fields, traffic.FieldStatusCode)
	}
	if m.addresponse_body_size != nil {
		fields = append(fields, traffic.FieldResponseBodySize)
	}
	if m.addduration_ms != nil {
		fields = append(fields, traffic.FieldDurationMs)
	}
	if m.addttfb_ms != nil {
		fields = append(fields, traffic.FieldTtfbMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrafficMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case traffic.FieldRequestBodySize:
		return m.AddedRequestBodySize()
	case traffic.FieldStatusCode:
		return m.AddedStatusCode()
	case traffic.FieldResponseBodySize:
		return m.AddedResponseBodySize()
	case traffic.FieldDurationMs:
		return m.AddedDurationMs()
	case traffic.FieldTtfbMs:
		return m.AddedTtfbMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrafficMutation) AddField(name string, value ent.Value) error {
	switch name {
	case traffic.FieldRequestBodySize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequestBodySize(v)
		return nil
	case traffic.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusCode(v)
		return nil
	case traffic.FieldResponseBodySize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResponseBodySize(v)
		return nil
	case traffic.FieldDurationMs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	case traffic.FieldTtfbMs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTtfbMs(v)
		return nil
	}
	return fmt.Errorf("unknown Traffic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrafficMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(traffic.FieldQuery) {
		fields = append(fields, traffic.FieldQuery)
	}
	if m.FieldCleared(traffic.FieldRequestHeaders) {
		fields = append(fields, traffic.FieldRequestHeaders)
	}
	if m.FieldCleared(traffic.FieldRequestBody) {
		fields = append(fields, traffic.FieldRequestBody)
	}
	if m.FieldCleared(traffic.FieldContentType) {
		fields = append(fields, traffic.FieldContentType)
	}
	if m.FieldCleared(traffic.FieldStatusText) {
		fields = append(fields, traffic.FieldStatusText)
	}
	if m.FieldCleared(traffic.FieldResponseHeaders) {
		fields = append(fields, traffic.FieldResponseHeaders)
	}
	if m.FieldCleared(traffic.FieldResponseBody) {
		fields = append(fields, traffic.FieldResponseBody)
	}
	if m.FieldCleared(traffic.FieldResponseContentType) {
		fields = append(fields, traffic.FieldResponseContentType)
	}
	if m.FieldCleared(traffic.FieldTtfbMs) {
		fields = append(fields, traffic.FieldTtfbMs)
	}
	if m.FieldCleared(traffic.FieldClientIP) {
		fields = append(fields, traffic.FieldClientIP)
	}
	if m.FieldCleared(traffic.FieldError) {
		fields = append(fields, traffic.FieldError)
	}
	if m.FieldCleared(traffic.FieldTags) {
		fields = append(fields, traffic.FieldTags)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrafficMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrafficMutation) ClearField(name string) error {
	switch name {
	case traffic.FieldQuery:
		m.ClearQuery()
		return nil
	case traffic.FieldRequestHeaders:
		m.ClearRequestHeaders()
		return nil
	case traffic.FieldRequestBody:
		m.ClearRequestBody()
		return nil
	case traffic.FieldContentType:
		m.ClearContentType()
		return nil
	case traffic.FieldStatusText:
		m.ClearStatusText()
		return nil
	case traffic.FieldResponseHeaders:
		m.ClearResponseHeaders()
		return nil
	case traffic.FieldResponseBody:
		m.ClearResponseBody()
		return nil
	case traffic.FieldResponseContentType:
		m.ClearResponseContentType()
		return nil
	case traffic.FieldTtfbMs:
		m.ClearTtfbMs()
		return nil
	case traffic.FieldClientIP:
		m.ClearClientIP()
		return nil
	case traffic.FieldError:
		m.ClearError()
		return nil
	case traffic.FieldTags:
		m.ClearTags()
		return nil
	}
	return fmt.Errorf("unknown Traffic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrafficMutation) ResetField(name string) error {
	switch name {
	case traffic.FieldMethod:
		m.ResetMethod()
		return nil
	case traffic.FieldURL:
		m.ResetURL()
		return nil
	case traffic.FieldScheme:
		m.ResetScheme()
		return nil
	case traffic.FieldHost:
		m.ResetHost()
		return nil
	case traffic.FieldPath:
		m.ResetPath()
		return nil
	case traffic.FieldQuery:
		m.ResetQuery()
		return nil
	case traffic.FieldRequestHeaders:
		m.ResetRequestHeaders()
		return nil
	case traffic.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	case traffic.FieldRequestBodySize:
		m.ResetRequestBodySize()
		return nil
	case traffic.FieldRequestIsBinary:
		m.ResetRequestIsBinary()
		return nil
	case traffic.FieldContentType:
		m.ResetContentType()
		return nil
	case traffic.FieldStatusCode:
		m.ResetStatusCode()
		return nil
	case traffic.FieldStatusText:
		m.ResetStatusText()
		return nil
	case traffic.FieldResponseHeaders:
		m.ResetResponseHeaders()
		return nil
	case traffic.FieldResponseBody:
		m.ResetResponseBody()
		return nil
	case traffic.FieldResponseBodySize:
		m.ResetResponseBodySize()
		return nil
	case traffic.FieldResponseIsBinary:
		m.ResetResponseIsBinary()
		return nil
	case traffic.FieldResponseContentType:
		m.ResetResponseContentType()
		return nil
	case traffic.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case traffic.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case traffic.FieldTtfbMs:
		m.ResetTtfbMs()
		return nil
	case traffic.FieldClientIP:
		m.ResetClientIP()
		return nil
	case traffic.FieldError:
		m.ResetError()
		return nil
	case traffic.FieldTags:
		m.ResetTags()
		return nil
	case traffic.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Traffic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrafficMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.proxy != nil {
		edges = append(edges, traffic.EdgeProxy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrafficMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case traffic.EdgeProxy:
		if id := m.proxy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrafficMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrafficMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrafficMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproxy {
		edges = append(edges, traffic.EdgeProxy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrafficMutation) EdgeCleared(name string) bool {
	switch name {
	case traffic.EdgeProxy:
		return m.clearedproxy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrafficMutation) ClearEdge(name string) error {
	switch name {
	case traffic.EdgeProxy:
		m.ClearProxy()
		return nil
	}
	return fmt.Errorf("unknown Traffic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrafficMutation) ResetEdge(name string) error {
	switch name {
	case traffic.EdgeProxy:
		m.ResetProxy()
		return nil
	}
	return fmt.Errorf("unknown Traffic edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op               Op
	typ              string
	id               *int
	email            *string
	name             *string
	password_hash    *string
	role             *user.Role
	auth_provider    *user.AuthProvider
	auth_provider_id *string
	avatar_url       *string
	active           *bool
	last_login_at    *time.Time
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	org              *int
	clearedorg       bool
	sessions         map[int]struct{}
	removedsessions  map[int]struct{}
	clearedsessions  bool
	done             bool
	oldValue         func(context.Context) (*User, error)
	predicates       []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ClearPasswordHash clears the value of the "password_hash" field.
func (m *UserMutation) ClearPasswordHash() {
	m.password_hash = nil
	m.clearedFields[user.FieldPasswordHash] = struct{}{}
}

// PasswordHashCleared returns if the "password_hash" field was cleared in this mutation.
func (m *UserMutation) PasswordHashCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswordHash]
	return ok
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
	delete(m.clearedFields, user.FieldPasswordHash)
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetAuthProvider sets the "auth_provider" field.
func (m *UserMutation) SetAuthProvider(up user.AuthProvider) {
	m.auth_provider = &up
}

// AuthProvider returns the value of the "auth_provider" field in the mutation.
func (m *UserMutation) AuthProvider() (r user.AuthProvider, exists bool) {
	v := m.auth_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthProvider returns the old "auth_provider" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAuthProvider(ctx context.Context) (v user.AuthProvider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthProvider: %w", err)
	}
	return oldValue.AuthProvider, nil
}

// ResetAuthProvider resets all changes to the "auth_provider" field.
func (m *UserMutation) ResetAuthProvider() {
	m.auth_provider = nil
}

// SetAuthProviderID sets the "auth_provider_id" field.
func (m *UserMutation) SetAuthProviderID(s string) {
	m.auth_provider_id = &s
}

// AuthProviderID returns the value of the "auth_provider_id" field in the mutation.
func (m *UserMutation) AuthProviderID() (r string, exists bool) {
	v := m.auth_provider_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthProviderID returns the old "auth_provider_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAuthProviderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthProviderID: %w", err)
	}
	return oldValue.AuthProviderID, nil
}

// ClearAuthProviderID clears the value of the "auth_provider_id" field.
func (m *UserMutation) ClearAuthProviderID() {
	m.auth_provider_id = nil
	m.clearedFields[user.FieldAuthProviderID] = struct{}{}
}

// AuthProviderIDCleared returns if the "auth_provider_id" field was cleared in this mutation.
func (m *UserMutation) AuthProviderIDCleared() bool {
	_, ok := m.clearedFields[user.FieldAuthProviderID]
	return ok
}

// ResetAuthProviderID resets all changes to the "auth_provider_id" field.
func (m *UserMutation) ResetAuthProviderID() {
	m.auth_provider_id = nil
	delete(m.clearedFields, user.FieldAuthProviderID)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetActive sets the "active" field.
func (m *UserMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserMutation) ResetActive() {
	m.active = nil
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrgID sets the "org" edge to the Org entity by id.
func (m *UserMutation) SetOrgID(id int) {
	m.org = &id
}

// ClearOrg clears the "org" edge to the Org entity.
func (m *UserMutation) ClearOrg() {
	m.clearedorg = true
}

// OrgCleared reports if the "org" edge to the Org entity was cleared.
func (m *UserMutation) OrgCleared() bool {
	return m.clearedorg
}

// OrgID returns the "org" edge ID in the mutation.
func (m *UserMutation) OrgID() (id int, exists bool) {
	if m.org != nil {
		return *m.org, true
	}
	return
}

// OrgIDs returns the "org" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrgID instead. It exists only for internal usage by the builders.
func (m *UserMutation) OrgIDs() (ids []int) {
	if id := m.org; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrg resets all changes to the "org" edge.
func (m *UserMutation) ResetOrg() {
	m.org = nil
	m.clearedorg = false
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...int) {
	if m.sessions == nil {
		m.sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...int) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []int) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []int) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.auth_provider != nil {
		fields = append(fields, user.FieldAuthProvider)
	}
	if m.auth_provider_id != nil {
		fields = append(fields, user.FieldAuthProviderID)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.active != nil {
		fields = append(fields, user.FieldActive)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldRole:
		return m.Role()
	case user.FieldAuthProvider:
		return m.AuthProvider()
	case user.FieldAuthProviderID:
		return m.AuthProviderID()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldActive:
		return m.Active()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldAuthProvider:
		return m.OldAuthProvider(ctx)
	case user.FieldAuthProviderID:
		return m.OldAuthProviderID(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldActive:
		return m.OldActive(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldAuthProvider:
		v, ok := value.(user.AuthProvider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthProvider(v)
		return nil
	case user.FieldAuthProviderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthProviderID(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldPasswordHash) {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.FieldCleared(user.FieldAuthProviderID) {
		fields = append(fields, user.FieldAuthProviderID)
	}
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldPasswordHash:
		m.ClearPasswordHash()
		return nil
	case user.FieldAuthProviderID:
		m.ClearAuthProviderID()
		return nil
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldAuthProvider:
		m.ResetAuthProvider()
		return nil
	case user.FieldAuthProviderID:
		m.ResetAuthProviderID()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldActive:
		m.ResetActive()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.org != nil {
		edges = append(edges, user.EdgeOrg)
	}
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOrg:
		if id := m.org; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorg {
		edges = append(edges, user.EdgeOrg)
	}
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeOrg:
		return m.clearedorg
	case user.EdgeSessions:
		return m.clearedsessions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeOrg:
		m.ClearOrg()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeOrg:
		m.ResetOrg()
		return nil
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
